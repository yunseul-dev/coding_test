/**동적 계획법(Dynamic Programming) 개념
 * 하나의 큰 문제를 해결하기 위해서 큰 문제를 작은 문제로 나누어 해결한 후
 * 작은 문제로부터 계산된 결과값을 이용하여 전체 문제를 해결하는 알고리즘
 *
 * 하나의 큰 문제를 여러 개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용하는 방법
 * 작은 문제의 답을 저장해두면 큰 문제를 풀 때 중복해서 발생하는 작은 문제들의 답을 미리 알기에 캐싱하듯이 사용할 수 있다.
 *
 * 즉, 동적 게획법을 사용하는 가장 큰 이유는
 * 큰 문제를 풀다 보면 중복되는 연산이 발생하게 되는데
 * 이 중복 연산들을 미리 저장하고 재활용하여 수행 연산의 성능을 증대 시킬 수 있음.
 * ex) 피보나치 수열
 */
/**동적 계획법 조건
 * 동적 계획법을 적용하기 위해서는 아래의 두 가지 속성을 만족해야 한다.
 * - Overlapping Subproblems(부분 반복 문제)
 *    큰 문제를 해결할 때 동일한 작은 문제가 반복하여 나타나는 경우
 * - Optimal Substructure(최적 부분 구조)
 *    작은 문제에서 구한 최적 결과 값을 통해 큰 문제의 최적 결과를 도출할 수 있는 경우
 */

/**메모이제이션(Memoization)
 * 큰 문제를 해결할 때 쪼개진 작은 문제들의 최적 결과 값을 메모리에 저장하여
 * 저장된 값을 통해 동일한 계산의 반복 수행을 줄여 큰 문제를 푸는데 있어 성능을 향상시키는 방법
 * => 동적 계획법의 색심
 */

/**동적 계획법 문제 푸는 과정 (관점)
 * 1. 특정 문제를 직면했을 때 DP로 풀 수 있을지에 대한 판단
 * 2. 큰 문제를 작은 문제로 나눌 수 있는지 판단
 *  - 피보나치 수열처럼 20번째 피보나치를 계산하기 위해선 18번째 + 19번째의 답을 알면 된다.
 *  - 즉, 작은 문제들로 푼할하여 큰 문제를 해결할 수 있을지 판단
 * 3. N-1번째와 N번째에 대한 관계를 고민해보고 점화식을 구성
 *  - 점화식을 세울 수 있는지 보고 작은 문제의 답이 큰 문제에서도 쓰일 수 있는지 판단
 * 4. 구성한 점화식을 이용한 메모이제이션
 *  - 문제의 결과를 저장할 요소(배열 등등)를 미리 만들어 두어 작은 문제에 대한 결과를 저장해두고
 *    저장된 값을 재사용하여 큰 문제를 해결해 나간다.
 *  - 이러한 메모이제이션을 통해 실제 코드에서 작은 문제의 답을 기억하게 하여 큰 문제를 풀 때 빠르게 풀 수 있다.
 * 5. 구현
 *  - Top-Down 방식: 재귀호출을 통해 큰 문제에서 작은 문제로 나누어 가며 문제를 푸는 방식
 *  - Bottom-Up 방식: for문을 통해 작은 문제를 풀며 점차 큰 문제를 푸는 방식
 */

/**동적 계획법 vs 분할 정복
 * 공통점
 *  - 큰 문제를 해결하기 위해 작은 문제로 나누어 해결해 나가는 과정일 동일
 * 차이점
 *  - 동적 계획법과 분할 정복의 가장 큰 차이는 메모이제이션의 사용 여부
 *  - 동적 계획법은 작은 문제의 결과 값을 저장하여 재활용
 *  - 분할 정복은 작은 문제의 결과 값을 저장하지 않음, 단 문제를 나누는 과정에서 부분 문제들은 서로 중복되지 않음
 */

/** Q1.
 * 2*N 직사각형을 1*2, 2*1, 2*2 타일로 채우는 방법의 수를 모두 구해보자.
 * 아래 예제는 N = 7인 2*17의 직사각형을 채운 예제이다.
 */

function dp1(N) {
  // let N = 2; // 3
  // let N = 12; // 2731

  let dp = Array.from({ length: N + 1 }, () => 0);

  // dp[n] -> 2*n 직사각형을 1*2, 2*1, 2*2 타일로 채우는 방법의 수
  dp[1] = 1; // 1*2 1개
  dp[2] = 3; // 1*2 2개 혹은 2*1 1개 혹은 2*2 1개

  for (let i = 3; i <= N; i++) {
    dp[i] = dp[i - 1] + dp[i - 2] * 2;
  }

  return dp[N];
}

/**Q2.
 * N*M 배열에 0,1로 된 배열이 있을 때, 배열에서 1로 된 가장 큰 정사각형 길이를 찾아보자.
 */

function dp2(N, M, arr) {
  // let N = 5;
  // let M = 5;

  // let arr = [
  //   [0, 0, 0, 0, 0, 0],
  //   [0, 0, 0, 0, 0, 1],
  //   [0, 0, 0, 1, 1, 0],
  //   [0, 1, 1, 1, 1, 1],
  //   [0, 0, 1, 1, 1, 1],
  //   [0, 0, 1, 1, 0, 1],
  // ];

  // dp[y][x] = y,x번째에서 만들 수 있는 정사각형의 최대 길이
  let dp = Array.from({ length: N + 1 }, () => {
    return Array.from({ length: M + 1 }, () => 0);
  });

  let ans = 0;
  for (let i = 1; i <= N; i++) {
    for (let j = 1; j <= M; j++) {
      if (arr[i][j]) {
        // arr[i][j] = 0이면 최대 정사각형을 만들 수 없는 자리기 때문에 무시
        // 왼쪽,위,윗대각성 중 최솟값 +1
        dp[i][j] =
          Math.min(dp[i - 1][j - 1], Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;

        ans = Math.max(dp[i][j], ans);
      }
    }
  }

  return ans;
}
